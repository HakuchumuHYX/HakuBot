import time
import asyncio
import json
from pathlib import Path
from io import BytesIO
from datetime import datetime

from nonebot import on_command, require
from nonebot.adapters.onebot.v11 import Message, MessageSegment
from nonebot.params import CommandArg
from nonebot.log import logger

# === 图像处理库 ===
try:
    from PIL import Image, ImageDraw, ImageFont
except ImportError:
    logger.error("请安装 Pillow: pip install Pillow")
    Image = None

# === 引入依赖 ===
require("nonebot_plugin_htmlrender")
require("nonebot_plugin_apscheduler")

from nonebot_plugin_htmlrender import get_new_page
from nonebot_plugin_apscheduler import scheduler

# === Stealth 库 ===
try:
    from playwright_stealth import Stealth
except ImportError:
    Stealth = None
    logger.warning("未检测到 playwright-stealth 库，将在无伪装模式下运行。")

# === 全局配置 ===
CACHE_EXPIRE_SECONDS = 5 * 60
FILE_CLEAN_SECONDS = 24 * 60 * 60
BASE_DIR = Path(__file__).parent
CACHE_DIR = Path() / "data" / "sekai_cache"
CONFIG_FILE = BASE_DIR / "config.json"
FONT_FILE = BASE_DIR / "font.ttf"

CACHE_DIR.mkdir(parents=True, exist_ok=True)


# === 读取 Config ===
def load_config():
    if not CONFIG_FILE.exists():
        logger.warning("config.json 不存在，使用默认配置")
        return {
            "url_home": "https://sekairanking.exmeaning.com/",
            "url_event_prefix": "https://sekairanking.exmeaning.com/event/",
            "watermark_text_1": "Designed and Powered by SnowyBot",
            "watermark_text_2": "Generated by HakuBot"
        }
    return json.loads(CONFIG_FILE.read_text(encoding="utf-8"))


# === 并发限制 ===
RENDER_SEMAPHORE = asyncio.Semaphore(3)

# 注册命令
shot_cmd = on_command("cnsk预测", priority=5, block=True)


# === 图片水印处理函数 ===
def add_watermark(img_bytes: bytes, config: dict) -> bytes:
    if not Image:
        return img_bytes

    image = Image.open(BytesIO(img_bytes))

    # 如果是 RGBA 模式 (PNG)，转为 RGB 以便保存为 JPEG
    if image.mode == 'RGBA':
        image = image.convert('RGB')

    width, height = image.size

    # 自动吸取背景色
    try:
        bg_color = image.getpixel((0, height - 1))
    except Exception:
        bg_color = (255, 255, 255)

    # 设置扩展区域高度
    padding_bottom = 160
    new_height = height + padding_bottom

    # 创建新画布
    new_image = Image.new("RGB", (width, new_height), bg_color)
    new_image.paste(image, (0, 0))

    draw = ImageDraw.Draw(new_image)

    # 加载字体
    try:
        if FONT_FILE.exists():
            font = ImageFont.truetype(str(FONT_FILE), 24)
        else:
            font = ImageFont.truetype("arial.ttf", 24)
    except Exception:
        logger.warning("字体加载失败，使用默认位图字体")
        font = ImageFont.load_default()

    current_time_str = datetime.now().strftime("%H:%M:%S %b. %d %Y")

    text_lines = [
        config.get("watermark_text_1", "111"),
        config.get("watermark_text_2", "222"),
        current_time_str
    ]

    # 绘制文字 (右对齐)
    current_y = height + 20
    margin_right = 40
    line_spacing = 15
    text_color = (160, 160, 160)

    for line in text_lines:
        if hasattr(draw, "textbbox"):
            bbox = draw.textbbox((0, 0), line, font=font)
            text_w = bbox[2] - bbox[0]
            text_h = bbox[3] - bbox[1]
        else:
            text_w, text_h = draw.textsize(line, font=font)

        x = width - text_w - margin_right
        draw.text((x, current_y), line, font=font, fill=text_color)
        current_y += text_h + line_spacing

    # 导出为 JPEG 以提高速度和减小体积
    output = BytesIO()
    new_image.save(output, format="JPEG", quality=85)
    return output.getvalue()


# === 截图函数 ===
async def manual_capture_page(url: str, viewport: dict, device_scale_factor: float, timeout: int) -> bytes:
    user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

    # 使用 1.5 倍缩放平衡清晰度与速度
    async with get_new_page(
            device_scale_factor=1.5,
            viewport=viewport,
            user_agent=user_agent,
            is_mobile=False,
            has_touch=False
    ) as page:
        # 应用伪装
        if Stealth:
            stealth = Stealth()
            await stealth.apply_stealth_async(page)

        # 访问网页
        await page.goto(url, wait_until="domcontentloaded", timeout=timeout)

        # 动态等待 CF 盾
        for _ in range(10):
            title = await page.title()
            if "Just a moment" in title or "Verify" in title or "Cloudflare" in title:
                logger.debug("Cloudflare 验证中...")
                await page.wait_for_timeout(1000)
            else:
                break

        # 智能等待数据加载
        try:
            logger.debug("等待数据加载...")
            loading_selector = ".loading-text"

            # 如果检测到 Loading 遮罩，等待其变为隐藏状态
            if await page.locator(loading_selector).is_visible():
                await page.locator(loading_selector).wait_for(state="hidden", timeout=15000)
                logger.debug("Loading 遮罩已隐藏")

            # 确认图表 canvas 可见
            await page.wait_for_selector("canvas", state="visible", timeout=5000)

            # 短暂缓冲以确保渲染完成
            await page.wait_for_timeout(200)

        except Exception as e:
            logger.warning(f"智能等待异常: {e}，尝试直接截图...")

        # 截图为 JPEG 格式
        return await page.screenshot(full_page=True, type="jpeg", quality=85)


@shot_cmd.handle()
async def handle_screenshot(args: Message = CommandArg()):
    arg_text = args.extract_plain_text().strip()
    config = load_config()

    target_url = ""
    cache_filename = ""
    log_name = ""

    if not arg_text:
        target_url = config["url_home"]
        cache_filename = "home.jpg"
        log_name = "当前活动"
    elif arg_text.isdigit():
        target_url = f"{config['url_event_prefix']}{arg_text}"
        cache_filename = f"{arg_text}.jpg"
        log_name = f"活动 {arg_text}"
    else:
        await shot_cmd.finish("参数错误。\n发送“cnsk预测”查看首页，或“cnsk预测 150”查看特定活动。")

    image_path = CACHE_DIR / cache_filename
    current_time = time.time()

    # 检查缓存
    if image_path.exists():
        file_mtime = image_path.stat().st_mtime
        if current_time - file_mtime < CACHE_EXPIRE_SECONDS:
            logger.info(f"[{log_name}] 命中缓存")
            await shot_cmd.finish(MessageSegment.image(image_path))
        else:
            logger.info(f"[{log_name}] 缓存过期")

    await shot_cmd.send(f"正在获取 [{log_name}] 的最新数据...")

    final_img_bytes = None
    error_msg = ""

    async with RENDER_SEMAPHORE:
        try:
            raw_img = await manual_capture_page(
                url=target_url,
                viewport={"width": 1280, "height": 1080},
                device_scale_factor=1.5,
                timeout=30000,
            )

            if raw_img:
                final_img_bytes = add_watermark(raw_img, config)
                image_path.write_bytes(final_img_bytes)
            else:
                error_msg = "截图结果为空"

        except Exception as e:
            error_msg = str(e)
            logger.error(f"[{log_name}] 截图失败: {e}")

    # 发送结果
    if final_img_bytes:
        await shot_cmd.finish(MessageSegment.image(final_img_bytes))

    elif image_path.exists():
        logger.warning(f"获取失败，使用旧缓存发送。错误: {error_msg}")
        await shot_cmd.finish(
            Message(f"网络获取失败，以下是上次 [{log_name}] 的缓存（可能已过时）：\n") +
            MessageSegment.image(image_path)
        )
    else:
        await shot_cmd.finish(f"获取失败，请稍后再试。\n错误信息: {error_msg}")


# === 定时清理 ===
@scheduler.scheduled_job("cron", hour=4, minute=0, id="clean_sekai_cache")
async def clean_cache():
    logger.info("开始清理截图缓存...")
    count = 0
    current_time = time.time()
    for file in CACHE_DIR.iterdir():
        if file.is_file() and file.suffix in [".png", ".jpg", ".jpeg"]:
            if current_time - file.stat().st_mtime > FILE_CLEAN_SECONDS:
                try:
                    file.unlink()
                    count += 1
                except Exception:
                    pass
    logger.info(f"缓存清理完成，共删除了 {count} 张过期图片。")
