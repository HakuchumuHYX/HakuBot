import time
import asyncio
import json
from pathlib import Path
from io import BytesIO
from datetime import datetime

from nonebot import on_command, require
from nonebot.adapters.onebot.v11 import Message, MessageSegment
from nonebot.params import CommandArg
from nonebot.log import logger

# === 图像处理库 ===
try:
    from PIL import Image, ImageDraw, ImageFont
except ImportError:
    logger.error("请安装 Pillow: pip install Pillow")
    Image = None

# === 引入依赖 ===
require("nonebot_plugin_htmlrender")
require("nonebot_plugin_apscheduler")

from nonebot_plugin_htmlrender import get_new_page
from nonebot_plugin_apscheduler import scheduler

try:
    from playwright_stealth import Stealth
except ImportError:
    Stealth = None
    logger.warning("未检测到 playwright-stealth 库，将在无伪装模式下运行。")

# === 全局配置 ===
CACHE_EXPIRE_SECONDS = 5 * 60
FILE_CLEAN_SECONDS = 24 * 60 * 60
BASE_DIR = Path(__file__).parent  # 当前插件所在目录
CACHE_DIR = Path() / "data" / "sekai_cache"
CONFIG_FILE = BASE_DIR / "config.json"
FONT_FILE = BASE_DIR / "font.ttf"  # 字体文件路径

CACHE_DIR.mkdir(parents=True, exist_ok=True)


# === 读取 Config ===
def load_config():
    if not CONFIG_FILE.exists():
        logger.warning("config.json 不存在，使用默认配置")
        return {
            "url_home": "https://baidu.com",
            "url_event_prefix": "https://baidu.com",
            "watermark_text_1": "Designed and Powered by xxx",
            "watermark_text_2": "Generated by xxx"
        }
    return json.loads(CONFIG_FILE.read_text(encoding="utf-8"))


# === 并发限制 ===
RENDER_SEMAPHORE = asyncio.Semaphore(3)

# 注册命令
shot_cmd = on_command("cnsk预测", priority=5, block=True)


# === 图片水印处理函数 ===
def add_watermark(img_bytes: bytes, config: dict) -> bytes:
    if not Image:
        return img_bytes  # 如果没装 Pillow，直接返回原图

    # 1. 打开图片
    image = Image.open(BytesIO(img_bytes))
    width, height = image.size

    # --- 修改点 1: 自动吸取背景色 ---
    # 读取原图左下角 (或者右下角) 的像素颜色，作为扩展区域的背景色
    # 这样无论是白色还是浅灰色背景，都能完美融合
    try:
        # 取 (0, height-1) 即左下角像素
        bg_color = image.getpixel((0, height - 1))
    except Exception:
        # 如果获取失败，兜底用白色
        bg_color = (255, 255, 255)

    # 2. 设置扩展区域高度
    padding_bottom = 160  # 稍微加大一点高度给大间距
    new_height = height + padding_bottom

    # 3. 创建新画布 (使用吸取的 bg_color)
    new_image = Image.new("RGB", (width, new_height), bg_color)
    new_image.paste(image, (0, 0))  # 将原图贴在上面

    # 4. 准备画笔
    draw = ImageDraw.Draw(new_image)

    # --- 修改点 2: 加载本地字体 font.ttf ---
    try:
        if FONT_FILE.exists():
            font = ImageFont.truetype(str(FONT_FILE), 24)  # 稍微调大一点字号
        else:
            # 如果没找到 font.ttf，尝试系统字体
            font = ImageFont.truetype("arial.ttf", 24)
    except Exception:
        logger.warning("字体加载失败，使用默认位图字体")
        font = ImageFont.load_default()

    # 5. 生成文字内容
    current_time_str = datetime.now().strftime("%H:%M:%S %b. %d %Y")

    text_lines = [
        config.get("watermark_text_1", "Designed by HakuBot"),
        config.get("watermark_text_2", "Generated by HakuBot"),
        current_time_str
    ]

    # 6. 绘制文字 (右对齐)
    current_y = height + 20  # 起始 Y 坐标
    margin_right = 40  # 距离右边的边距
    line_spacing = 15  # --- 修改点 3: 增大字间距 ---

    # --- 修改点 4: 浅灰色文字 ---
    # (160, 160, 160) 是比较浅的灰色，如果背景也是灰色，可能需要调整
    # 如果想更浅一点，可以改到 (180, 180, 180)
    text_color = (160, 160, 160)

    for line in text_lines:
        # 获取文字宽高
        if hasattr(draw, "textbbox"):  # Pillow >= 9.2.0
            bbox = draw.textbbox((0, 0), line, font=font)
            text_w = bbox[2] - bbox[0]
            text_h = bbox[3] - bbox[1]
        else:  # 旧版 Pillow
            text_w, text_h = draw.textsize(line, font=font)

        x = width - text_w - margin_right

        draw.text((x, current_y), line, font=font, fill=text_color)
        current_y += text_h + line_spacing

    # 7. 导出图片
    output = BytesIO()
    new_image.save(output, format="PNG")
    return output.getvalue()


# === 截图函数 ===
async def manual_capture_page(url: str, viewport: dict, device_scale_factor: float, timeout: int) -> bytes:
    user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

    async with get_new_page(
            device_scale_factor=device_scale_factor,
            viewport=viewport,
            user_agent=user_agent,
            is_mobile=False,
            has_touch=False
    ) as page:
        # 只有当导入成功时才执行
        if Stealth:
            stealth = Stealth()
            await stealth.apply_stealth_async(page)

        await page.goto(url, wait_until="domcontentloaded", timeout=timeout)

        title = await page.title()
        if "Just a moment" in title or "Verify" in title or "Cloudflare" in title:
            logger.info("检测到 Cloudflare 验证页面，正在等待跳转...")
            await page.wait_for_timeout(8000)
        else:
            await page.wait_for_timeout(3000)

        return await page.screenshot(full_page=True)


@shot_cmd.handle()
async def handle_screenshot(args: Message = CommandArg()):
    arg_text = args.extract_plain_text().strip()
    config = load_config()

    # === 参数解析 ===
    target_url = ""
    cache_filename = ""
    log_name = ""

    if not arg_text:
        target_url = config["url_home"]
        cache_filename = "home.png"
        log_name = "当前活动"
    elif arg_text.isdigit():
        target_url = f"{config['url_event_prefix']}{arg_text}"
        cache_filename = f"{arg_text}.png"
        log_name = f"活动 {arg_text}"
    else:
        await shot_cmd.finish("参数错误。\n发送“cnsk预测”查看首页，或“cnsk预测 150”查看特定活动。")

    image_path = CACHE_DIR / cache_filename
    current_time = time.time()

    # --- 1. 检查缓存 ---
    if image_path.exists():
        file_mtime = image_path.stat().st_mtime
        if current_time - file_mtime < CACHE_EXPIRE_SECONDS:
            logger.info(f"[{log_name}] 命中缓存")
            await shot_cmd.finish(MessageSegment.image(image_path))
        else:
            logger.info(f"[{log_name}] 缓存过期")

    # --- 2. 重新获取 ---
    await shot_cmd.send(f"正在获取 [{log_name}] 的最新数据...")

    # 结果变量
    final_img_bytes = None
    error_msg = ""

    async with RENDER_SEMAPHORE:
        try:
            raw_img = await manual_capture_page(
                url=target_url,
                viewport={"width": 1280, "height": 1080},
                device_scale_factor=2,
                timeout=30000,
            )

            if raw_img:
                # === 加上水印 ===
                final_img_bytes = add_watermark(raw_img, config)

                # === 保存缓存 ===
                image_path.write_bytes(final_img_bytes)
            else:
                error_msg = "截图结果为空"

        except Exception as e:
            error_msg = str(e)
            logger.error(f"[{log_name}] 截图失败: {e}")

    # --- 3. 统一发送逻辑 ---
    if final_img_bytes:
        await shot_cmd.finish(MessageSegment.image(final_img_bytes))

    elif image_path.exists():
        logger.warning(f"获取失败，使用旧缓存发送。错误: {error_msg}")
        await shot_cmd.finish(
            Message(f"网络获取失败，以下是上次 [{log_name}] 的缓存（可能已过时）：\n") +
            MessageSegment.image(image_path)
        )
    else:
        await shot_cmd.finish(f"获取失败，请稍后再试。\n错误信息: {error_msg}")


# === 定时清理 ===
@scheduler.scheduled_job("cron", hour=4, minute=0, id="clean_sekai_cache")
async def clean_cache():
    logger.info("开始清理截图缓存...")
    count = 0
    current_time = time.time()
    for file in CACHE_DIR.iterdir():
        if file.is_file() and file.suffix == ".png":
            if current_time - file.stat().st_mtime > FILE_CLEAN_SECONDS:
                try:
                    file.unlink()
                    count += 1
                except Exception:
                    pass
    logger.info(f"缓存清理完成，共删除了 {count} 张过期图片。")