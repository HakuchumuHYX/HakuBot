from __future__ import annotations

from dataclasses import dataclass
from io import BytesIO
from typing import Iterable, Optional

from .plot import (
    Canvas,
    FillBg,
    HSplit,
    RoundRectBg,
    Spacer,
    TextBox,
    TextStyle,
    VSplit,
)

# NOTE:
# - 本模块目标：提供“可复用”的卡片渲染函数，避免插件侧各写一份画图逻辑。
# - 实现完全基于 PIL/plot/painter，不依赖 htmlrender。
# - 返回值统一为 PNG bytes，便于 NoneBot 直接 MessageSegment.image(bytes) 发送。


@dataclass(frozen=True)
class LeaderboardCardColors:
    # 画布背景（不要纯白，避免刺眼）
    canvas_bg: tuple[int, int, int, int] = (228, 245, 255, 255)  # 浅蓝
    # 卡片背景
    card_bg: tuple[int, int, int, int] = (243, 251, 255, 255)  # 更浅的蓝白
    # 卡片边框
    card_border: tuple[int, int, int, int] = (170, 210, 235, 255)

    # 行背景
    row_bg: tuple[int, int, int, int] = (236, 248, 255, 255)

    # 文本颜色
    text_main: tuple[int, int, int, int] = (25, 55, 75, 255)
    text_sub: tuple[int, int, int, int] = (80, 120, 140, 255)
    text_muted: tuple[int, int, int, int] = (120, 150, 165, 255)

    # Badge（排名）
    badge_1_bg: tuple[int, int, int, int] = (255, 235, 170, 255)  # 金
    badge_2_bg: tuple[int, int, int, int] = (235, 241, 247, 255)  # 银
    badge_3_bg: tuple[int, int, int, int] = (255, 225, 210, 255)  # 铜
    badge_other_bg: tuple[int, int, int, int] = (219, 234, 254, 255)  # 淡蓝


# Dark mode 配色预设，适合深夜推送场景
DARK_COLORS = LeaderboardCardColors(
    canvas_bg=(30, 32, 40, 255),          # 深灰蓝底
    card_bg=(40, 44, 55, 255),            # 深色卡片
    card_border=(60, 65, 80, 255),        # 低对比边框
    row_bg=(48, 52, 65, 255),             # 行背景
    text_main=(220, 225, 235, 255),       # 浅白文字
    text_sub=(160, 170, 185, 255),        # 次要文字
    text_muted=(110, 120, 135, 255),      # 水印等
    badge_1_bg=(180, 150, 60, 255),       # 金（降低亮度）
    badge_2_bg=(120, 130, 145, 255),      # 银
    badge_3_bg=(170, 110, 80, 255),       # 铜
    badge_other_bg=(55, 65, 90, 255),     # 深蓝
)


def _badge_bg_by_rank(colors: LeaderboardCardColors, rank: int) -> tuple[int, int, int, int]:
    if rank == 1:
        return colors.badge_1_bg
    if rank == 2:
        return colors.badge_2_bg
    if rank == 3:
        return colors.badge_3_bg
    return colors.badge_other_bg


async def render_leaderboard_card(
    *,
    title: str,
    subtitle: str | None = None,
    total: int,
    total_label: str | None = "总消息数",
    rows: Iterable[tuple[str, int]],
    footer: Optional[str] = None,
    watermark: str | None = None,
    width: int = 720,
    colors: LeaderboardCardColors | None = None,
) -> bytes:
    """渲染通用排行榜/统计卡片（轻量，无 htmlrender）。

    Args:
        title: 卡片标题（如 "【今日消息统计】"）
        subtitle: 副标题（建议放“统计日期”等信息）
        total: 大号显示的总数值
        total_label: 总数上方的小标题文案（如“总消息数”）；为空则不显示
        rows: 排行榜行数据，格式 [(name, count), ...]
        footer: 底部附加文字（可选）
        watermark: 右下角水印（可选，默认 "Generated by HakuBot"）
        width: 图片宽度（建议 650~800）
        colors: 配色方案（可选）

    Returns:
        PNG bytes
    """
    colors = colors or LeaderboardCardColors()

    # ---- 布局常量（统一在这里调） ----
    outer_margin = 24
    card_padding_x = 22
    card_padding_y = 22

    # 文本样式
    title_style = TextStyle(font="SourceHanSansCN-Heavy", size=34, color=colors.text_main)
    subtitle_style = TextStyle(font="SourceHanSansCN-Regular", size=18, color=colors.text_sub)
    total_label_style = TextStyle(font="SourceHanSansCN-Regular", size=16, color=colors.text_sub)
    total_value_style = TextStyle(font="SourceHanSansCN-Heavy", size=54, color=colors.text_main)

    row_name_style = TextStyle(font="SourceHanSansCN-Regular", size=20, color=colors.text_main)
    row_count_style = TextStyle(font="SourceHanSansCN-Bold", size=20, color=colors.text_main)
    badge_style = TextStyle(font="SourceHanSansCN-Bold", size=18, color=colors.text_main)

    footer_style = TextStyle(font="SourceHanSansCN-Regular", size=18, color=colors.text_main)
    watermark_style = TextStyle(font="SourceHanSansCN-Regular", size=14, color=colors.text_muted)

    # 这是真正“内容区域”的宽度（卡片内部）
    content_w = width - outer_margin * 2 - card_padding_x * 2

    # ---- 构建卡片内容 ----
    items: list = []

    # 标题区
    items.append(TextBox(title, style=title_style, wrap=True, use_real_line_count=True).set_w(content_w).set_padding(0))
    if subtitle:
        items.append(
            TextBox(subtitle, style=subtitle_style, wrap=True, use_real_line_count=True)
            .set_w(content_w)
            .set_padding(0)
        )

    items.append(Spacer(1, 10))

    # 总数区
    if total_label:
        items.append(TextBox(total_label, style=total_label_style).set_w(content_w).set_padding(0))
    items.append(TextBox(str(total), style=total_value_style).set_w(content_w).set_padding(0))

    items.append(Spacer(1, 16))

    # 榜单区
    row_widgets = []
    rows_list = list(rows)
    if rows_list:
        row_sep = 10
        for idx, (name, count) in enumerate(rows_list, start=1):
            # 每行内的表格布局：badge | name | count
            inner_sep = 12
            ratios = [1.3, 6.0, 2.1]
            ratio_sum = sum(ratios)

            # 行本身有 padding，会压缩 content 区域宽度；这里按 content 区宽度计算列宽
            row_padding_x = 14
            inner_content_w = content_w - row_padding_x * 2

            unit_w = (inner_content_w - inner_sep * 2) / ratio_sum
            w_badge = int(unit_w * ratios[0])
            w_name = int(unit_w * ratios[1])
            w_count = int(inner_content_w - inner_sep * 2 - w_badge - w_name)

            badge_bg = _badge_bg_by_rank(colors, idx)

            badge = (
                TextBox(f"#{idx}", style=badge_style, wrap=False)
                .set_w(w_badge)
                .set_content_align("c")
                .set_bg(RoundRectBg(fill=badge_bg, radius=12))
                .set_padding((10, 6))
                .set_margin(0)
            )

            name_box = (
                TextBox(str(name), style=row_name_style, wrap=False, overflow="shrink")
                .set_w(w_name)
                .set_content_align("l")
                .set_padding(0)
                .set_margin(0)
            )

            count_box = (
                TextBox(f"{count} 条", style=row_count_style, wrap=False, overflow="shrink")
                .set_w(w_count)
                .set_content_align("r")
                .set_padding(0)
                .set_margin(0)
            )

            row = (
                HSplit(items=[badge, name_box, count_box], sep=inner_sep, item_size_mode="expand", ratios=ratios)
                .set_w(content_w)
                .set_padding((row_padding_x, 10))
                .set_margin(0)
                .set_bg(RoundRectBg(fill=colors.row_bg, radius=16))
            )
            row_widgets.append(row)

        items.append(
            VSplit(items=row_widgets, sep=row_sep, item_size_mode="fixed", item_align="c")
            .set_w(content_w)
            .set_padding(0)
            .set_margin(0)
        )
    else:
        items.append(TextBox("暂无排行数据", style=subtitle_style).set_w(content_w).set_padding(0))

    # footer
    if footer:
        items.append(Spacer(1, 14))
        items.append(
            TextBox(str(footer), style=footer_style, wrap=True, use_real_line_count=True)
            .set_w(content_w)
            .set_padding(0)
        )

    items.append(Spacer(1, 10))
    if watermark is None:
        watermark = "Generated by HakuBot"
    if watermark:
        items.append(
            TextBox(watermark, style=watermark_style, wrap=False)
            .set_w(content_w)
            .set_content_align("r")
            .set_padding(0)
        )

    # 卡片容器（圆角背景 + padding）
    card = (
        VSplit(items=items, sep=10, item_size_mode="fixed", item_align="c")
        .set_w(width - outer_margin * 2)
        .set_padding((card_padding_x, card_padding_y))
        .set_margin(outer_margin)
        .set_bg(RoundRectBg(fill=colors.card_bg, radius=26, stroke=colors.card_border, stroke_width=2))
    )

    # 画布（浅色底）
    canvas = Canvas(w=width, h=None, bg=FillBg(colors.canvas_bg))
    canvas.set_items([card]).set_content_align("c")

    img = await canvas.get_img()

    buf = BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()
